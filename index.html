<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Nine Men's Morris — Web Game (AI対応)</title>
  <meta name="description" content="Nine Men's Morris (モリス) をブラウザで遊べるシングルファイル版。AI対戦ON/OFF切替。" />
  <style>
    :root{
      --bg:#0f1220;          /* app background */
      --panel:#171a2b;       /* side/top panels */
      --ink:#e7eaf6;         /* text */
      --muted:#9aa3c2;       /* secondary text */
      --accent:#7aa2ff;      /* focus / primary */
      --good:#33d17a;        /* valid */
      --bad:#ff6b6b;         /* error */
      --p1:#ffd166;          /* Player W piece */
      --p2:#7bdff2;          /* Player B piece */
    }
    html,body{height:100%;}
    body{ margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", Meiryo, "Noto Sans JP", sans-serif;
      color:var(--ink); background:radial-gradient(1200px 800px at 70% -10%, #1c2140 0%, #0f1220 55%);
      display:grid; place-items:center; }
    .wrap{ width:min(100%,1100px); padding:16px; }
    header{ display:flex; gap:12px; align-items:center; justify-content:space-between; margin-bottom:12px; }
    .title{ font-weight:700; letter-spacing:.3px; }
    .title small{ display:block; font-weight:500; color:var(--muted); }
    .toolbar{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    button{ background:var(--panel); border:1px solid #262c4a; color:var(--ink); padding:.55rem .8rem; border-radius:12px; cursor:pointer; font-weight:600; }
    button:hover{ outline:2px solid #26346a; }
    button:active{ transform:translateY(1px); }
    .pill{ padding:.35rem .6rem; border-radius:999px; border:1px solid #2a3153; background:#141831; color:var(--muted); font-size:.9rem; }
    .pill strong{ color:var(--ink); }
    .board-area{ display:grid; grid-template-columns: 1fr 320px; gap:16px; }
    @media (max-width: 960px){ .board-area{ grid-template-columns: 1fr; } }
    .board{ aspect-ratio:1/1; background:linear-gradient(180deg, #171a2b, #161a2f); border:1px solid #262c4a; border-radius:18px; position:relative; overflow:hidden;
      box-shadow: 0 10px 30px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.03); }
    svg{ position:absolute; inset:0; width:100%; height:100%; }
    .node{ cursor:pointer; transition:transform .12s ease, fill .2s ease, stroke .2s ease; }
    .node:focus{ outline:none; }
    .node:hover{ filter:brightness(1.2); }
    .dot-empty{ fill:#252b4b; stroke:#3b4579; stroke-width:3; }
    .dot-legal{ stroke:var(--good); }
    .dot-selected{ stroke:var(--accent); filter:drop-shadow(0 0 6px rgba(122,162,255,.6)); }
    .dot-removable{ stroke:var(--bad); filter:drop-shadow(0 0 6px rgba(255,107,107,.5)); }
    .piece{ pointer-events:none; }
    .piece.W{ fill:var(--p1); }
    .piece.B{ fill:var(--p2); }
    .piece-shadow{ fill:#000; opacity:.25; }
    .side{ background:var(--panel); border:1px solid #262c4a; border-radius:18px; padding:16px; display:flex; flex-direction:column; gap:12px; }
    .side h2{ margin:0; font-size:1.1rem; letter-spacing:.2px; }
    .status{ background:#12162b; border:1px solid #242a4d; border-radius:12px; padding:12px; min-height:3.5em; display:flex; gap:10px; align-items:flex-start; }
    .turn-indicator{ width:10px; height:10px; border-radius:50%; margin-top:.45em; }
    .turn-W{ background:var(--p1); box-shadow:0 0 8px var(--p1); }
    .turn-B{ background:var(--p2); box-shadow:0 0 8px var(--p2); }
    details{ background:#12162b; border:1px solid #242a4d; border-radius:12px; padding:10px 12px; }
    details summary{ cursor:pointer; color:var(--muted); }
    details[open] summary{ color:var(--ink); }
    .list{ display:grid; grid-template-columns:1fr 1fr; gap:6px 12px; }
    .list div{ color:var(--muted); }
    .list strong{ color:var(--ink); }
    .footer-note{ color:var(--muted); font-size:.92rem; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">
        <div style="font-size:1.35rem">Nine Men's Morris <span style="font-size:1rem; color:var(--muted)">（ナインメンズモリス）</span></div>
        <small>2人対戦／AI対戦ON-OFF。クリック操作のみ／GitHub Pagesで動作。</small>
      </div>
      <div class="toolbar">
        <button id="btn-new" title="新しい対局">New Game</button>
        <button id="btn-undo" title="ひとつ戻す（配置・移動・除去の直前まで）">Undo</button>
        <button id="btn-ai" title="AI(B)と対戦のON/OFF">Play vs AI: <span id="ai-state">OFF</span></button>
        <span class="pill">phase: <strong id="phase-label">placing</strong></span>
      </div>
    </header>

    <section class="board-area">
      <div class="board">
        <svg id="board" viewBox="0 0 700 700" aria-label="Nine Men's Morris board" role="img"></svg>
      </div>

      <aside class="side">
        <h2>Game Status</h2>
        <div class="status" id="status">
          <div class="turn-indicator turn-W" id="turn-dot" aria-hidden="true"></div>
          <div>
            <div id="status-line">W の配置です。空点をクリックしてください。</div>
            <div class="list" style="margin-top:6px">
              <div>W 残り配置: <strong id="w-to-place">9</strong></div>
              <div>B 残り配置: <strong id="b-to-place">9</strong></div>
              <div>W 盤上枚数: <strong id="w-on">0</strong></div>
              <div>B 盤上枚数: <strong id="b-on">0</strong></div>
            </div>
          </div>
        </div>

        <details>
          <summary>How to play（簡易ルール）</summary>
          <ul>
            <li><strong>配置フェーズ:</strong> 交互に空点へ置く（各9枚）。3つ一直線の <em>Mill</em>（ミル）で相手石を1つ除去（ミルを成していない石を優先）。</li>
            <li><strong>移動フェーズ:</strong> 置き終えたら、隣接線に沿って1点移動。自石が3枚になったら <em>Flying</em>（どこへでも可）。</li>
            <li><strong>勝敗:</strong> 相手の盤上石が<strong>2枚以下</strong>、または<strong>合法手なし</strong>で勝ち。</li>
          </ul>
        </details>
      </aside>
    </section>
  </div>

  <script>
    // === Nine Men's Morris — 2P + optional AI(B) ===

    const NODES = [["A1",0,0],["D1",3,0],["G1",6,0],["B2",1,1],["D2",3,1],["F2",5,1],["C3",2,2],["D3",3,2],["E3",4,2],["A4",0,3],["B4",1,3],["C4",2,3],["E4",4,3],["F4",5,3],["G4",6,3],["C5",2,4],["D5",3,4],["E5",4,4],["B6",1,5],["D6",3,5],["F6",5,5],["A7",0,6],["D7",3,6],["G7",6,6]];
    const NEI = {0:[1,9],1:[0,2,4],2:[1,14],3:[4,10],4:[3,5,1,7],5:[4,13],6:[7,11],7:[6,8,4],8:[7,12],9:[0,10,21],10:[9,11,3,18],11:[10,6,15],12:[8,13,17],13:[12,14,5,20],14:[13,2,23],15:[11,16],16:[15,17,19],17:[16,12],18:[19,10],19:[18,20,16,22],20:[19,13],21:[9,22],22:[21,23,19],23:[22,14]};
    const MILLS = [[0,1,2],[3,4,5],[6,7,8],[9,10,11],[12,13,14],[15,16,17],[18,19,20],[21,22,23],[0,9,21],[3,10,18],[6,11,15],[1,4,7],[16,19,22],[8,12,17],[5,13,20],[2,14,23]];

    const svg = document.getElementById('board');
    const PHASE_LABEL = document.getElementById('phase-label');
    const STATUS_LINE = document.getElementById('status-line');
    const TURN_DOT = document.getElementById('turn-dot');
    const W_TO_PLACE = document.getElementById('w-to-place');
    const B_TO_PLACE = document.getElementById('b-to-place');
    const W_ON = document.getElementById('w-on');
    const B_ON = document.getElementById('b-on');
    const BTN_NEW = document.getElementById('btn-new');
    const BTN_UNDO = document.getElementById('btn-undo');
    const BTN_AI = document.getElementById('btn-ai');
    const AI_STATE = document.getElementById('ai-state');

    const UNIT = 100, MARGIN = 50;
    const gx = x => MARGIN + x*UNIT; const gy = y => MARGIN + y*UNIT;
    const line = (x1,y1,x2,y2)=>`<line x1="${gx(x1)}" y1="${gy(y1)}" x2="${gx(x2)}" y2="${gy(y2)}" stroke="#3b4579" stroke-width="6" stroke-linecap="round"/>`;

    function drawBoardLines(){
      const ls=[]; ls.push(line(0,0,6,0),line(6,0,6,6),line(6,6,0,6),line(0,6,0,0));
      ls.push(line(1,1,5,1),line(5,1,5,5),line(5,5,1,5),line(1,5,1,1));
      ls.push(line(2,2,4,2),line(4,2,4,4),line(4,4,2,4),line(2,4,2,2));
      ls.push(line(3,0,3,2),line(0,3,2,3),line(4,3,6,3),line(3,4,3,6));
      svg.insertAdjacentHTML('beforeend', ls.join('\n'));
    }
    function drawNodes(){
      NODES.forEach((n, idx)=>{
        const [name,x,y] = n; const cx=gx(x), cy=gy(y);
        const g = document.createElementNS('http://www.w3.org/2000/svg','g');
        g.setAttribute('data-idx', idx); g.setAttribute('tabindex','0'); g.setAttribute('role','button'); g.classList.add('node');
        g.innerHTML = `
          <circle class="dot-empty" r="16" cx="${cx}" cy="${cy}" />
          <circle class="piece-shadow" r="20" cx="${cx}" cy="${cy+2}" opacity="0" />
          <circle class="piece" r="20" cx="${cx}" cy="${cy}" opacity="0" />
          <text x="${cx}" y="${cy-28}" text-anchor="middle" fill="#5e6997" font-size="14" font-weight="600">${name}</text>`;
        svg.appendChild(g);
      });
    }

    let state; let history=[];
    const newState = () => ({ board:Array(24).fill(null), turn:'W', toPlace:{W:9,B:9}, phase:'placing', selected:null, mustRemove:false, gameOver:false, winner:null, message:'', aiEnabled:false, locked:false });
    const clone = o => JSON.parse(JSON.stringify(o));
    const pushHistory = ()=>{ history.push(clone(state)); updateUndoBtn(); };
    const popHistory = ()=>{ if(history.length){ state = history.pop(); renderAll(); } updateUndoBtn(); runAiIfNeeded(); };
    const updateUndoBtn = ()=>{ BTN_UNDO.disabled = history.length===0; };
    const opponent = p => p==='W'?'B':'W';
    const piecesOn = p => state.board.filter(v=>v===p).length;

    function isMillAt(index,p){ for(const m of MILLS){ if(m.includes(index) && m.every(i=>state.board[i]===p)) return true; } return false; }
    const indicesOfPlayer = p => { const r=[]; state.board.forEach((v,i)=>{ if(v===p) r.push(i); }); return r; };
    const emptyIndices = ()=>{ const r=[]; state.board.forEach((v,i)=>{ if(!v) r.push(i); }); return r; };
    function removableIndicesFor(op){ const all=indicesOfPlayer(op); const non=all.filter(i=>!isMillAt(i,op)); return non.length?non:all; }

    function hasAnyLegalMove(p){ if(state.phase!=='moving') return true; const c=piecesOn(p); const empties=emptyIndices(); if(empties.length===0) return false; if(c<=3) return c>0; for(const i of indicesOfPlayer(p)) for(const nb of NEI[i]) if(!state.board[nb]) return true; return false; }

    const setMessage = t => { state.message=t; STATUS_LINE.textContent=t; };
    const setPhaseLabel = ()=>{ PHASE_LABEL.textContent = state.phase; };
    const updateSideCounts = ()=>{ W_TO_PLACE.textContent=state.toPlace.W; B_TO_PLACE.textContent=state.toPlace.B; W_ON.textContent=piecesOn('W'); B_ON.textContent=piecesOn('B'); };
    const renderTurn = ()=>{ TURN_DOT.className = 'turn-indicator ' + (state.turn==='W'?'turn-W':'turn-B'); };

    function renderPieces(){
      const nodes = svg.querySelectorAll('.node');
      nodes.forEach(node=>{
        const idx=+node.getAttribute('data-idx'); const dot=node.querySelector('.dot-empty'); const piece=node.querySelector('.piece'); const sh=node.querySelector('.piece-shadow');
        dot.className='dot-empty';
        const v=state.board[idx];
        if(v){ piece.setAttribute('opacity','1'); sh.setAttribute('opacity','1'); piece.setAttribute('class','piece '+v); }
        else { piece.setAttribute('opacity','0'); sh.setAttribute('opacity','0'); }
      });
      if(state.gameOver) return;
      const turn=state.turn;
      if(state.mustRemove){ const opp=opponent(turn); for(const i of removableIndicesFor(opp)) svg.querySelector(`.node[data-idx="${i}"] .dot-empty`).classList.add('dot-removable'); return; }
      if(state.phase==='placing'){ for(const i of emptyIndices()) svg.querySelector(`.node[data-idx="${i}"] .dot-empty`).classList.add('dot-legal'); return; }
      if(state.selected!=null){ const from=state.selected; const c=piecesOn(turn); const dests=(c<=3)?emptyIndices():NEI[from].filter(i=>!state.board[i]); dests.forEach(i=> svg.querySelector(`.node[data-idx="${i}"] .dot-empty`).classList.add('dot-legal')); svg.querySelector(`.node[data-idx="${from}"] .dot-empty`).classList.add('dot-selected'); }
      else{ const c=piecesOn(turn); const movable=indicesOfPlayer(turn).filter(i=> c<=3 || NEI[i].some(j=>!state.board[j]) ); movable.forEach(i=> svg.querySelector(`.node[data-idx="${i}"] .dot-empty`).classList.add('dot-legal')); }
    }

    function renderAll(){ setPhaseLabel(); updateSideCounts(); renderPieces(); renderTurn();
      if(state.gameOver) setMessage(`Game Over: ${state.winner} wins! New Game で再開できます。`);
      else if(state.mustRemove) setMessage(`${state.turn} がミルを完成。相手の石を1つ除去してください。`);
      else if(state.phase==='placing') setMessage(`${state.turn} の配置です。空点をクリックしてください。`);
      else if(state.phase==='moving' && state.selected!=null) setMessage(`${state.turn} の移動：移動先を選んでください（${piecesOn(state.turn)<=3?'Flying可':'隣接のみ'}）`);
      else setMessage(`${state.turn} の手番。（${piecesOn(state.turn)} 枚 / ${piecesOn(state.turn)<=3?'Flying可':'隣接移動'}）`);
    }

    const switchTurn = ()=>{ state.turn = opponent(state.turn); state.selected=null; };
    const maybeEnterMovingPhase = ()=>{ if(state.phase==='placing' && state.toPlace.W===0 && state.toPlace.B===0){ state.phase='moving'; setPhaseLabel(); } };
    function checkGameEndAfterTurnSwitch(prev){ if(state.phase!=='moving') return; if(!hasAnyLegalMove(state.turn)){ state.gameOver=true; state.winner=prev; renderAll(); } }

    function applyRemoval(index){ const opp=opponent(state.turn); if(state.board[index]!==opp) return false; const removable=removableIndicesFor(opp); if(!removable.includes(index)) return false; pushHistory(); state.board[index]=null; state.mustRemove=false; maybeEnterMovingPhase(); if(state.phase==='moving' && piecesOn(opp)<3){ state.gameOver=true; state.winner=state.turn; renderAll(); return true; } const prev=state.turn; switchTurn(); checkGameEndAfterTurnSwitch(prev); renderAll(); return true; }
    function applyPlacement(index){ if(state.phase!=='placing'||state.mustRemove) return false; if(state.board[index]) return false; pushHistory(); state.board[index]=state.turn; state.toPlace[state.turn]--; if(isMillAt(index,state.turn)) state.mustRemove=true; else { const prev=state.turn; switchTurn(); maybeEnterMovingPhase(); checkGameEndAfterTurnSwitch(prev); } renderAll(); return true; }
    function applyMove(from,to){ if(state.phase!=='moving'||state.mustRemove) return false; if(state.board[from]!==state.turn||state.board[to]) return false; const c=piecesOn(state.turn); if(c>3 && !NEI[from].includes(to)) return false; pushHistory(); state.board[from]=null; state.board[to]=state.turn; state.selected=null; if(isMillAt(to,state.turn)) state.mustRemove=true; else { const prev=state.turn; switchTurn(); checkGameEndAfterTurnSwitch(prev); } renderAll(); return true; }

    // === Simple AI (Black) ===
    function runAiIfNeeded(){ if(state.aiEnabled && state.turn==='B' && !state.gameOver){ state.locked=true; setTimeout(aiStep, 420); } }
    function aiStep(){ if(state.gameOver){ state.locked=false; return; }
      if(state.mustRemove){ const idx = aiChooseRemoval(); applyRemoval(idx); state.locked=false; return; }
      if(state.phase==='placing'){ const idx = aiChoosePlacement(); applyPlacement(idx); if(state.mustRemove){ setTimeout(aiStep, 380); return; } state.locked=false; return; }
      const mv = aiChooseMove(); if(!mv){ state.gameOver=true; state.winner='W'; renderAll(); state.locked=false; return; }
      applyMove(mv.from, mv.to); if(state.mustRemove){ setTimeout(aiStep, 380); return; } state.locked=false; }

    const makesMillIfPlace = (i,p)=>{ if(state.board[i]) return false; state.board[i]=p; const ok=isMillAt(i,p); state.board[i]=null; return ok; };
    const wouldOpponentMakeMillIfPlace = (i,op)=>{ if(state.board[i]) return false; state.board[i]=op; const ok=isMillAt(i,op); state.board[i]=null; return ok; };

    function aiChoosePlacement(){ const empties=emptyIndices(); for(const i of empties){ if(makesMillIfPlace(i,'B')) return i; } for(const i of empties){ if(wouldOpponentMakeMillIfPlace(i,'W')) return i; } const pref=[1,4,7,9,10,11,12,13,14,16,19,22]; for(const i of pref){ if(empties.includes(i)) return i; } return empties[Math.floor(Math.random()*empties.length)]; }

    function aiChooseRemoval(){ const opp='W'; const cand=removableIndicesFor(opp); function potential(i){ let c=0; for(const m of MILLS){ if(m.includes(i)){ const others=m.filter(x=>x!==i); if(others.every(x=> state.board[x]==='W' || !state.board[x])) c++; } } return c; }
      let best=cand[0], sc=-1; for(const i of cand){ const s=potential(i); if(s>sc){ sc=s; best=i; } } return best; }

    function aiChooseMove(){ const p='B'; const moves=[]; const cnt=piecesOn(p); for(const from of indicesOfPlayer(p)){ const dests=(cnt<=3)?emptyIndices():NEI[from].filter(i=>!state.board[i]); for(const to of dests) moves.push({from,to}); } if(!moves.length) return null; function score(m){ let s=0; state.board[m.from]=null; state.board[m.to]='B'; if(isMillAt(m.to,'B')) s+=100; if(wouldOpponentMakeMillIfPlace(m.to,'W')) s+=30; const center=[1,4,7,9,10,11,12,13,14,16,19,22]; if(center.includes(m.to)) s+=3; state.board[m.to]=null; state.board[m.from]='B'; return s; }
      let best=moves[0], bestScore=-1; for(const mv of moves){ const sc=score(mv); if(sc>bestScore){ bestScore=sc; best=mv; } } return best; }

    function onNodeActivate(idx){ if(state.gameOver) return; if(state.aiEnabled && state.turn==='B') return; if(state.locked) return;
      if(state.mustRemove){ if(!applyRemoval(idx)) setMessage('除去できない石です。別の相手石を選んでください。'); else runAiIfNeeded(); return; }
      if(state.phase==='placing'){ if(!applyPlacement(idx)) setMessage('その点には置けません。'); else runAiIfNeeded(); return; }
      const v=state.board[idx]; if(state.selected==null){ if(v===state.turn){ state.selected=idx; renderAll(); } else setMessage('自分の石を選んでください。'); }
      else{ if(v===state.turn){ state.selected=idx; renderAll(); } else { if(!applyMove(state.selected, idx)) setMessage('その移動はできません。'); else runAiIfNeeded(); } }
    }

    function attachEvents(){
      svg.addEventListener('click', e=>{ const g=e.target.closest('.node'); if(!g) return; const idx=+g.getAttribute('data-idx'); onNodeActivate(idx); });
      svg.addEventListener('keydown', e=>{ if(e.key==='Enter'||e.key===' '){ const g=e.target.closest('.node'); if(!g) return; e.preventDefault(); const idx=+g.getAttribute('data-idx'); onNodeActivate(idx); } });
      BTN_NEW.addEventListener('click', ()=>{ history.length=0; state=newState(); updateUndoBtn(); renderAll(); });
      BTN_UNDO.addEventListener('click', ()=>{ popHistory(); });
      BTN_AI.addEventListener('click', ()=>{ state.aiEnabled=!state.aiEnabled; AI_STATE.textContent = state.aiEnabled? 'ON':'OFF'; if(state.aiEnabled && state.turn==='B') runAiIfNeeded(); });
    }

    function boot(){ drawBoardLines(); drawNodes(); attachEvents(); state=newState(); updateUndoBtn(); renderAll(); }
    boot();
  </script>
</body>
</html>